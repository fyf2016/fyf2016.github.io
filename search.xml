<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js获取元素绝对位置</title>
      <link href="/2018/12/31/js%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/12/31/js%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>众：哇！不会吧！博主你这都不会！</p><p>我：我…我还真的不会。</p><a id="more"></a><p>今天搞事情想搞个react动画框架。需要获取元素的绝对位置。</p><p>百度： <span style="font-size:12px;color:#888">不要和我说google 一样的货色</span></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//获取元素的纵坐标 </span><span class="token keyword">function</span> <span class="token function">getTop</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">var</span> offset<span class="token operator">=</span>e<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>offsetParent<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> offset<span class="token operator">+</span><span class="token operator">=</span><span class="token function">getTop</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>offsetParent<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> offset<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//获取元素的横坐标 </span><span class="token keyword">function</span> <span class="token function">getLeft</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">var</span> offset<span class="token operator">=</span>e<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>offsetParent<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> offset<span class="token operator">+</span><span class="token operator">=</span><span class="token function">getLeft</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>offsetParent<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> offset<span class="token punctuation">;</span> <span class="token punctuation">}</span> </code></pre><p>嗯 很合理嘛 Element.offsetTop + 递归。</p><p>可偶然发现这是获取元素在文档流中的位置，但 transform 属性是不会改变文档流中的位置的。好，我们换一个方法。结果百度 google翻了几页都是这一个方法</p><p><img src="/img/表情/喷.png" alt=""></p><p>继续寻找，突然想到jq，试了一下jq的offset方法，完美支持 transform 属性，mmp。</p><p>经查看jq源码，方法如下：</p><pre class=" language-js"><code class="language-js">offset<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> options <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Preserve chaining for setter</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> arguments<span class="token punctuation">.</span>length <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> options <span class="token operator">===</span> undefined <span class="token operator">?</span>      <span class="token keyword">this</span> <span class="token punctuation">:</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span> <span class="token punctuation">{</span>        jQuery<span class="token punctuation">.</span>offset<span class="token punctuation">.</span><span class="token function">setOffset</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">,</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> doc<span class="token punctuation">,</span> docElem<span class="token punctuation">,</span> rect<span class="token punctuation">,</span> win<span class="token punctuation">,</span>    elem <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>elem <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Return zeros for disconnected and hidden (display: none) elements (gh-2310)</span>  <span class="token comment" spellcheck="true">// Support: IE &lt;=11 only</span>  <span class="token comment" spellcheck="true">// Running getBoundingClientRect on a</span>  <span class="token comment" spellcheck="true">// disconnected node in IE throws an error</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>elem<span class="token punctuation">.</span><span class="token function">getClientRects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> top<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  rect <span class="token operator">=</span> elem<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  doc <span class="token operator">=</span> elem<span class="token punctuation">.</span>ownerDocument<span class="token punctuation">;</span>  docElem <span class="token operator">=</span> doc<span class="token punctuation">.</span>documentElement<span class="token punctuation">;</span>  win <span class="token operator">=</span> doc<span class="token punctuation">.</span>defaultView<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    top<span class="token punctuation">:</span> rect<span class="token punctuation">.</span>top <span class="token operator">+</span> win<span class="token punctuation">.</span>pageYOffset <span class="token operator">-</span> docElem<span class="token punctuation">.</span>clientTop<span class="token punctuation">,</span>    left<span class="token punctuation">:</span> rect<span class="token punctuation">.</span>left <span class="token operator">+</span> win<span class="token punctuation">.</span>pageXOffset <span class="token operator">-</span> docElem<span class="token punctuation">.</span>clientLeft  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>查阅mdn的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect()</a> 词条。</p><blockquote><p>Range.getBoundingClientRect() 返回一个 ClientRect 对象，该对象限定了选定的文档对象的内容，该方法返回了一个矩形，这个矩形包围了该文档对象中所有元素的边界矩形集合（译者注：关于边界矩形可以参考 <a href="http://en.wikipedia.org/wiki/Minimum_bounding_rectangle" target="_blank" rel="noopener">Minimum Bouding Rectangles</a>）。 </p></blockquote><p>以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects#Syntax" target="_blank" rel="noopener">getClientRects()</a></p><blockquote><p>返回值是ClientRect对象集合，该对象是与该元素相关的CSS边框。每个ClientRect对象包含一组描述该边框的只读属性——left、top、right和bottom，单位为像素，<strong>这些属性值是相对于视口的top-left的。</strong>即使当表格的标题在表格的边框外面，该标题仍会被计算在内。</p></blockquote><p>注意上文的 <code>这些属性值是相对于视口的top-left的。</code> 也就是说算出元素在页面的绝对位置还有加上视口滚动的距离。</p><p>所以jq的实现就是：</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>  top<span class="token punctuation">:</span> 元素顶部到视口顶部 <span class="token operator">+</span> 视口到页面顶部 <span class="token operator">-</span> 文档偏移  left<span class="token punctuation">:</span> 元素左侧到视口左侧 <span class="token operator">+</span> 视口到页面左侧 <span class="token operator">-</span> 文档偏移<span class="token punctuation">}</span></code></pre><p><span style="font-size:12px;color:#888">封面画师: <a href="http://www.pixiv.net/member.php?id=3273478" target="_blank" rel="noopener">squidsmith</a></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理课程设计</title>
      <link href="/2018/07/29/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E8%AE%BE/"/>
      <url>/2018/07/29/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-课程设计简介"><a href="#1-课程设计简介" class="headerlink" title="1. 课程设计简介"></a>1. 课程设计简介</h2><p>综合运用所学的计算机组成原理知识，掌握计算机各条指令运行的过程，<br>设计并实现较为完整的计算机运算过程。设计并实现任意两个八位二进制数的原码一位乘法，实现带有符号位的运算。</p><h2 id="2-实验设备"><a href="#2-实验设备" class="headerlink" title="2. 实验设备"></a>2. 实验设备</h2><p>TDN—CM+ 计算机组成原理实验教学系统一台, 排线若干。</p><h2 id="3-总体思路"><a href="#3-总体思路" class="headerlink" title="3. 总体思路"></a>3. 总体思路</h2><pre><code>(1) 完成接线, 实现基本的复杂模型机(2) 设计实现八位二进制数的原码一位乘法的汇编指令(3) 运行并调试程序</code></pre><h2 id="4-基本概念及原理"><a href="#4-基本概念及原理" class="headerlink" title="4. 基本概念及原理"></a>4. 基本概念及原理</h2><h3 id="4-1-数据格式"><a href="#4-1-数据格式" class="headerlink" title="4.1 数据格式"></a>4.1 数据格式</h3><pre><code>模型机规定采用定点补码表示法表示数据，且字长为8位，其格式如下：</code></pre><p><img src="/images/project/PcOrganization/1.png" alt=""></p><h3 id="4-2-指令格式"><a href="#4-2-指令格式" class="headerlink" title="4.2 指令格式"></a>4.2 指令格式</h3><pre><code>模型机设计四大类指令共十六条，其中包括算术逻辑指令、I/O指令、访问及转移指令和停机指令。        (1) 算数逻辑指令    设计9条算术逻辑指令并用单字节表示，寻址方式采用寄存器直接寻址，其格式如下：</code></pre><p><img src="/images/project/PcOrganization/2.png" alt=""></p><pre><code>    其中，OP－CODE为操作码，rs为源寄存器，rd为目的寄存器，并规定：</code></pre><p><img src="/images/project/PcOrganization/3.png" alt=""></p><pre><code>（2）访存指令及转移指令     模型机设计2条访存指令――存数（STA）和取数（LDA），2条转移指令指,即无条件转移指令（JMP）     和结果为零或有进位转移指令（BZC），指令格式为：</code></pre><p><img src="/images/project/PcOrganization/4.png" alt=""></p><pre><code>     其中，OP－CODE为操作码，rd为目的寄存器地址（LDA、STA指令使用）。     D为偏移量（正负均可），M为寻址模式，其定义如下：</code></pre><p><img src="/images/project/PcOrganization/5.png" alt=""></p><pre><code>     本模型机规定变址寄存器RI指定为寄存器R2（3）I/O指令     输入（IN）和输出（OUT）指令采用单字节指令，其格式如下：</code></pre><p><img src="/images/project/PcOrganization/6.png" alt=""></p><pre><code>     其中，addr＝01时，选中“INPUT DEVICE”中的开关组作为输入设备，     addr＝10时，选中“OUTPUT DEVICE”中的数码块作为输出设备。（4）停机指令     指令格式如下：</code></pre><p><img src="/images/project/PcOrganization/7.png" alt=""></p><pre><code>     HALT指令用于实现停机操作.</code></pre><h3 id="4-3-指令系统"><a href="#4-3-指令系统" class="headerlink" title="4.3 指令系统"></a>4.3 指令系统</h3><pre><code>本模型机共有16条基本指令，其中算术逻辑指令7条，访存指令和程序控制指令4条，输入输出指令2条，其它指令1条，表列出了各条指令的格式、汇编符号、指令功能。</code></pre><p><img src="/images/project/PcOrganization/8.png" alt=""></p><h3 id="4-4-接线图"><a href="#4-4-接线图" class="headerlink" title="4.4 接线图"></a>4.4 接线图</h3><hr><h2 id=""><a href="#" class="headerlink" title="    "></a><img src="/images/project/PcOrganization/9.png" alt="">    </h2><h2 id="5-总体流程"><a href="#5-总体流程" class="headerlink" title="5. 总体流程"></a>5. 总体流程</h2><h3 id="5-1-流程图"><a href="#5-1-流程图" class="headerlink" title="5.1 流程图"></a>5.1 流程图</h3><p><img src="/images/project/PcOrganization/10.png" alt=""></p><pre><code>实现过程：（1）向寄存器R0中存入10000000，向寄存器R1中存入被乘数X，清零R2,将R0与R1中存入的X值进行与操作,     求得X的符号位,将X的符号位存入到F0H,将R1中存入的先左移再右移获得|X|(存入到F1H).（2）同上面的操作取得Y的符号位(存入到F2H)和|Y|(存入到F3H)。（3）将X和Y的符号位取异或操作,得到最终的符号位存入到F6H中（4）输入移位循环次数到R0寄存器中,将R2清零,初始化部分积,保存到F7H中.（5）清零cy,将乘数|Y|取出存到R1中,右移,判断最低位是0还是1.如果是0,则执行(6),如果是1,则执行(7).（6）从F7H中取出部分积到R1中,从F3H中取出部分积到R2,然后右移部分积,右移|y|,     将结果有保存到相应的地址中.执行跳转指令,执行(9)（7）取部分积到R1,取|X|到R2然后求部分积加|X|,结果保存到F7H中,然后将|y|右移并保存,清零R1,清零cy.（8）将计数次数右移,判断是否循环结束,若结束则向下执行,若未结束则跳转到(5).（9）将部分积与最终符号位相加.（10）输出高八位R1，第八位R2，停机结束。</code></pre><h3 id="5-2-实现原码一位乘的微指令"><a href="#5-2-实现原码一位乘的微指令" class="headerlink" title="5.2 实现原码一位乘的微指令"></a>5.2 实现原码一位乘的微指令</h3><pre class=" language-asm6502"><code class="language-asm6502">    汇编指令    助记符            注释    $ P0044    IN 01,R0         输入10000000    $ P0145    IN 01,R1         输入x    $ P0272    CLR00,R2         清零R2        $ P03F5    RLC R1,R1        左移X，移出符号位    $ P04EA    RRC R2,R2        右移R2，获得8位符号位    $ P0506    STA R2           将x符号位存到F0H    $ P06F0            $ P07EA    RRC R2,R2        清零cy    $ P08E5    RRC R1,R1        右移x获得|x|    $ P0905    STA R1           存|x|到F1H    $ P0AF1    F1H        $ P0B45    IN 01,R1         输入y    $ P0CF5    RLC R1,R1        左移Y移出符号位    $ P0DEA    RRC R2,R2        右移R2获得8位符号位    $ P0E06    STA R2           将Y符号位存到F2H    $ P0FF2    F2H        $ P10EA    RRC R2,R2        清零cy    $ P11E5    RRC R1,R1        右移y获得|y|    $ P1205    STA R1           存|y|到F3H    $ P13F3    F3H        $ P1401    LDA R1           取x的符号位到R1    $ P15F0    F0H        $ P1602    LDA R2           取y的符号位到R2    $ P17F2    F2H        $ P18D4    COM R1,R0        求x的反    $ P19C8    AND R2,R0        求（x的反）和y的与    $ P1A04    STA R0           存（x的反）和y的与的结果到F4    $ P1BF4    F4H        $ P1CD8    COM R2,RO        求Y的反    $ P1DC4    AND R1,R0        求（Y的反）和X的与    $ P1E04    STA R0           存（Y的反）和X的与的结果到F5H    $ P1FF5    F5H        $ P2001    LDA R1           取（x的反）和y的与的结果到R1    $ P21F4    F4H        $ P2202    LDA R2           取（y的反）和x的与的结果到R2    $ P23F5    F5H        $ P2470    CLR R0           清零R0    $ P25E0    RRC R0,RO        清零cy    $ P2696    ADC R1,R2        获得最终的符号位    $ P2706    STA R2           存最终符号位到F6H    $ P28F6    F6H        $ P2944    IN 01,R0         输入移位次数    $ P2A72    CLR R2           清零R2    $ P2B06    STA R2           保存部分积到F7H    $ P2CF7    F7H        $ P2DEA    RRC R2,R2        清零cy    $ P2E01    LDA R1           取|y|到R1    $ P2FF3    F3H        $ P30E5    RRC R1,R1        |Y|右移一位    $ P310C    BZC 00,00        判断最低位是0还是1    $ P323F    3FH              跳转地址3FH    $ P3301    LDA R1           取部分积到R1    $ P34F7    F7H        $ P3502    LDA R2           取|y|到R2    $ P36F3    F3H        $ P37E5    RRC R1,R1        右移部分积    $ P38EA    RRC R2,R2        右移|y|    $ P3905    STA R1           保存右移后的部分积到F7H    $ P3AF7    F7H        $ P3B06    STA R2           保存右移后的|y|到F3H    $ P3CF3    F3H        $ P3D08    JMP 00,00        跳转指令    $ P3E4E    4EH              跳转地址4EH    $ P3F01    LDA R1           取部分积到R1    $ P40F7    F7H        $ P4172    CLR R2           清零R2    $ P42EA    RRC R2,R2        清零cy    $ P4302    LDA R2           取|x|到R2    $ P44F1    F1H        $ P4596    ADC R1,R2        求部分积加|x|    $ P46EA    RRC R2,R2        右移相加后的部分积    $ P4706    STA R2           保存部分积到F7H    $ P48F7    F7H        $ P4902    LDA R2           取|y|到R2    $ P4AF3    F3H        $ P4BEA    RRC R2,R2        右移|y|    $ P4C06    STA R2           保存右移后的|y|到F3H    $ P4DF3    F3H        $ P4E71    CLR R1           清零R1    $ P4FE5    RRC R1,R1        清零cy    $ P50E0    RRC R0,R0        右移计数次数    $ P510C    BZC 00,00        判断循环是否结束    $ P5257    57H        $ P5371    CLR R1           清零R1    $ P54E5    RRC R1,R1        清零cy    $ P5508    JMP 00,00        跳转指令    $ P562F    2FH        $ P5701    LDA R1           取部分积到R1    $ P58F7    F7H        $ P5902    LDA R2           取最终符号到R2    $ P5AF6    F6H        $ P5B70    CLR R0           清零R0    $ P5CE0    RRC R0,R0        清零cy    $ P5D96    ADC R1,R2        求符号位加数值位    $ P5E5A    OUT R2           输出高8位    $ P5F01    LDA R1           取出低八位到R1    $ P60F3    F3H        $ P6159    OUT R1           输出低八位    $ P6260    HALT             待机</code></pre><h2 id="6-课设手稿"><a href="#6-课设手稿" class="headerlink" title="6. 课设手稿"></a>6. 课设手稿</h2><p><img src="/images/project/PcOrganization/ks1.jpg" alt=""><br><img src="/images/project/PcOrganization/ks2.jpg" alt=""><br><img src="/images/project/PcOrganization/ks3.jpg" alt=""><br><img src="/images/project/PcOrganization/ks4.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 汇编指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法三级项目(管道铺设系统)</title>
      <link href="/2018/07/22/%E7%AE%97%E6%B3%95%E4%B8%89%E7%BA%A7%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/07/22/%E7%AE%97%E6%B3%95%E4%B8%89%E7%BA%A7%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="项目开发大致流程"><a href="#项目开发大致流程" class="headerlink" title="项目开发大致流程"></a><span style="color:rgba(255,165,0,0.8);text-shadow:5px 5px 5px #ccc">项目开发大致流程</span></h2><p><span style="color:purple;text-shadow:5px 5px 5px #ccc ">1.&emsp;摘要</span></p><p><span style="color:orange;text-shadow:5px 5px 5px #ccc ">2.&emsp;项目要求</span></p><p><span style="color:green;text-shadow:5px 5px 5px #ccc ">3.&emsp;总体设计</span></p><p><span style="color:red;text-shadow:5px 5px 5px #ccc ">4.&emsp;结果演示</span></p><p><span style="color:#459df5;text-shadow:5px 5px 5px #ccc ">5.&emsp;项目配置</span></p><p><span style="color:black;text-shadow:5px 5px 5px #ccc ">6.&emsp;项目源代码</span></p><h2 id="1-emsp-摘要"><a href="#1-emsp-摘要" class="headerlink" title="1.&emsp;摘要"></a><span style="color:purple;text-shadow:5px 5px 5px #ccc ">1.&emsp;摘要</span></h2><p><br>    本次课程的三级项目是要求设计实现一个管线铺设辅助系统，设计算法并实现使铺设的输水管道距离最短。<br>本项目主要应用了最小生成树算法：<br>    prime算法和Kruskal算法两种算法，具备从文本读取数据、显示最佳铺设方案，以及绘制最佳方案的简单示意图等功能，以东校区各建筑物为例，实现了获得任意两个建筑物之间铺设管道的最佳方案。<br><br>    关键词：【最小生成树】  【prime算法】  【kruskal算法】<br></p><h2 id="2-emsp-项目要求"><a href="#2-emsp-项目要求" class="headerlink" title="2.&emsp;项目要求"></a><span style="color:orange;text-shadow:5px 5px 5px #ccc ">2.&emsp;项目要求</span></h2><p><br>    用最小生成树算法实现东区各建筑之间铺设的输水管道距离最短，需要满足如下要求 :<br><br>    <span style="display: block;float: left;width: 25px;height: 77px;">(1）</span>将管线经过的建筑物以及建筑物之间的距离，抽象成无向图，并以矩阵的形式表示，并保存在文本中，<br>    系统通过读取文本的方式，获取该矩阵；<br><br>    <span style="display: block;float: left;width: 25px;height: 77px;">(2）</span>从Prim算法和Kruskal算法中至少选择一种实现管线铺设的最优方案，系统可以最优方案<br>    的生成过程，并且可以文本的形式输出；<br><br>      (3）在系统上可以生成最优方案的简易图。<br><br><br></p><h2 id="3-emsp-总体设计"><a href="#3-emsp-总体设计" class="headerlink" title="3.&emsp;总体设计"></a><span style="color:green;text-shadow:5px 5px 5px #ccc ">3.&emsp;总体设计</span></h2><h3 id="3-1-大致划分"><a href="#3-1-大致划分" class="headerlink" title="3.1 大致划分"></a>3.1 大致划分</h3><p><br>    总体上将项目划分为前端和后端两个层面:<br>        &emsp;|— 前端: 主要负责展示良好的界面, 增强交互性<br>        &emsp;|— 后端: 主要负责实现项目的功能<br>    (1) 项目类型:<br>        &emsp;&emsp;javaWeb项目 (Servlet+Jsp)<br>    (2) 开发工具:<br>        &emsp;&emsp;MyEclipse + MySQL + Navicat<br>    (3) 前端界面的实现:<br>        &emsp;&emsp;通过 html + css + css3 + js + jquery 来实现<br>        &emsp;&emsp;1. 项目结果页面展现<br>        &emsp;&emsp;<img src="/images/project/arithmetic/view1.png" style=" margin-left: 50px;"><br>        <span style="display: block;float: left;width: 25px;height: 54px;margin-left: 32px;">web.xml:</span><br>        用于配置View层中Servlet服务器的信息和路径<br>        <span style="display: block;float: left;width: 25px;height: 50px;margin-left: 32px;">index.jsp:</span><br>        用于显示项目主页的页面<br>        <span style="display: block;float: left;width: 25px;height: 50px;margin-left: 32px;">kruskalPage.jsp:</span><br>        用于显示Kruskal算法处理结果的页面<br>        <span style="display: block;float: left;width: 25px;height: 50px;margin-left: 32px;">pirmePage.jsp:</span><br>        用于显示Kruskal算法处理结果的页面<br>        <span style="display: block;float: left;width: 25px;height: 50px;margin-left: 32px;">showScenery.jsp:</span><br>        用于显示周边建筑物信息的页面<br>        <span style="display: block;float: left;width: 25px;height: 60px;margin-left: 32px;">map.jsp:</span><br>        实现了简易图的绘制(引入百度地图api, 从后台传入经算法处理后的数据生成)<br><br>    (4) 绘制简易图功能的实现:<br>        &emsp;&emsp;引入百度地图api, 从后台传入经算法处理后的数据,然后生成对应最短路线<br></p><h3 id="3-2-算法的实现"><a href="#3-2-算法的实现" class="headerlink" title="3.2 算法的实现:"></a>3.2 算法的实现:</h3><p style="margin-left: 50px;"><br>        1. 算法所用数据结构选型<br><br>            <span style="display: block;margin-left: 15px;">所用矩阵： n*2矩阵</span><br>            <span style="display: block;margin-left: 15px;">选择原因：方便hashMap的存取。</span><br>            <span style="display: block;margin-left: 15px;">存放矩阵内信息所用数据结构：hashMap</span><br>            <span style="display: block;margin-left: 15px;">选择原因：</span><br>            <span style="display: block;margin-left: 15px;">letCode中有一道返回两数之和的算法题，通过条件遍历查询数组即可获得完成，但是官方推荐的是用hashMap存取并遍历，经过letCode上的大量数据测试，得出在这种情况下hashMap的执行效率更高，所用时间更少，通过分析两算法，得知都要按条件查询矩阵内容，所以对于这种规模的数据和相似的情况，我们采用hashMap来存取数据。</span><br>            <span style="display: block;margin-left: 15px;">存放无向图结点的数据结构： Set集合</span><br>            <span style="display: block;margin-left: 15px;">选择原因：</span><br>            <span style="display: block;margin-left: 15px;">集合具有元素无序不重复的特性，所以用来存放结点可以防止其重复出现。</span><br>            <span style="display: block;margin-left: 15px;">路径返回结果所用数据结构： ArrayList</span><br>            <span style="display: block;margin-left: 15px;">选择原因：</span><br>            <span style="display: block;margin-left: 15px;">ArrayList具有有序便于插入删除的特点，方便对结果进行后续的整理和修改。</span><br></p><br><p><br>        2. 算法的具体实现<br><br>            <img src="/images/project/arithmetic/back1.png" alt="" style=" margin-left: 20px;"><br>            <span style="display: block;margin-left: 15px;">Prime算法部分主要由PrimeServiceImpl实现</span><br>            <span style="display: block;margin-left: 15px;">kruskal算法部分主要由kruskalServiceImpl实现</span><br>            <span style="display: block;margin-left: 15px;">CaculateUtil.java :提取并封装了PrimeServiceImpl 和 KruskalServiceImpl算法用到的方法</span><br>            <span style="display: block;margin-left: 15px;">2.1 实现Prime算法的基本思想:</span><br></p><blockquote><ol><li>清空生成树，任取一个顶点加入生成树</li></ol></blockquote><blockquote><ol start="2"><li>在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树</li></ol></blockquote><blockquote><ol start="3"><li>重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树</li></ol></blockquote><p><br>    <span style="display: block;margin-left: 15px;">2.2 Prime算法适用性和时间复杂度:</span><br>    <span style="display: block;margin-left: 15px;">Prime算法求最小生成树时候，和边数无关，只和定点的数量相关，所以适合求稠密网的最小生成树，时间复杂度为O(n×n)</span><br></p><br><p><br>    <span style="display: block;margin-left: 15px;">2.3 实现Kruskal算法的基本思想:</span><br></p><blockquote><ol><li>首先将G的n个顶点看成n个孤立的连通分支（n个孤立点）并将所有的边按权从小大排序。</li></ol></blockquote><blockquote><ol start="2"><li>按照边权值递增顺序，如果加入边后存在环则这条边不加，直到形成连通图</li></ol></blockquote><p><br>    <span style="display: block;margin-left: 15px;">2.4 Kruskal算法适用性和时间复杂度:</span><br>    <span style="display: block;margin-left: 15px;">Kruskal算法是对图的边进行访问，所以Kruskal算法的时间复杂度只和边又关系，其时间复杂度为O（eloge）</span><br></p><h2 id="4-emsp-结果演示"><a href="#4-emsp-结果演示" class="headerlink" title="4.&emsp;结果演示"></a><span style="color:red;text-shadow:5px 5px 5px #ccc ">4.&emsp;结果演示</span></h2><h3 id="4-1-项目主要界面展示"><a href="#4-1-项目主要界面展示" class="headerlink" title="4.1 项目主要界面展示"></a>4.1 项目主要界面展示</h3><blockquote><p>首页</p></blockquote><p><img src="/images/project/arithmetic/index.png" alt="" style=" "></p><blockquote><p>节点信息展示</p></blockquote><p><img src="/images/project/arithmetic/nodeMsg.png" alt="" style=" "></p><blockquote><p>Prime算法界面</p></blockquote><p><img src="/images/project/arithmetic/prime.png" alt="" style=" "></p><blockquote><p>Kruskal算法界面</p></blockquote><p><img src="/images/project/arithmetic/kruskal.png" alt="" style=" "></p><blockquote><p>最终生成的路线图</p></blockquote><p><img src="/images/project/arithmetic/map.png" alt="" style=" "></p><hr><h3 id="4-2-项目运行演示"><a href="#4-2-项目运行演示" class="headerlink" title="4.2 项目运行演示"></a>4.2 项目运行演示</h3><blockquote><p>以下两个地址都可</p></blockquote><p>腾讯云对象存储COS视频地址:<br><a href="https://video-1254265973.cos.ap-beijing.myqcloud.com/arithmetic.mp4" target="_blank" rel="noopener">https://video-1254265973.cos.ap-beijing.myqcloud.com/arithmetic.mp4</a><br>哔哔哩哔哩视频地址:<br><a href="https://www.bilibili.com/video/av40697433/" target="_blank" rel="noopener">https://www.bilibili.com/video/av40697433/</a></p><h2 id="5-emsp-项目配置"><a href="#5-emsp-项目配置" class="headerlink" title="5.&emsp;项目配置"></a><span style="color:#459df5;text-shadow:5px 5px 5px #ccc ">5.&emsp;项目配置</span></h2><blockquote><p>5.1 矩阵文件格式</p></blockquote><p> 矩阵文件的格式应为N*2矩阵, 形式如 AB 150 。 A, B 为结点的编号, 150为两结点结点间的距离。<br> 详细配置可参照项目中的ReadDatas.txt和ReadDatas3.txt。</p><blockquote><p>5.2 读入文件路径的设置</p></blockquote><p>  读入文件的路径设置在 PipeLineLaying/src/com/dao/impl/ReadDataDAOImpl.java 里面修改,<br>  修改位置为下图标红线的地方:</p><hr><p>  <img src="/images/project/arithmetic/readPath.png" alt="" style=" "></p><hr><blockquote><p>5.3 输出文件路径的设置</p></blockquote><p>  输出最终结果的路径设置在 PipeLineLaying/src/com/dao/impl/OutputDataDAOImpl.java 里面修改,<br>  修改位置为下图标红线的地方:</p><p>  <img src="/images/project/arithmetic/outputPath.png" alt="" style=" ">    </p><blockquote><p>5.4 数据库配置</p></blockquote><p> (1) 数据库连接信息可在项目下的 src/jdbc.properties 文件中修改,<br>       &ensp;&emsp;下图标红线的位置对应的是 自己数据库的名字(类型为Mysql数据库)。</p><hr><p> <img src="/images/project/arithmetic/jdbc.png" alt="" style=" ">    </p><hr><p> (2) 将项目中的 pipelying.sql 导入自己电脑的本地数据库<br>     &ensp;&emsp;演示Navicat导入的方式:<br>     &ensp;&emsp;右键连接–&gt;选择运行SQL文件–&gt;选中pipelying.sql–&gt;运行完毕点击关闭–&gt;右键刷新。<br>     &ensp;&emsp;完成以上步骤后, pipelying数据库便成功导入到了你的本地数据库中。</p><hr><p> <img src="/images/project/arithmetic/database.png" alt="" style=" ">    </p><hr><h2 id="6-emsp-项目源代码"><a href="#6-emsp-项目源代码" class="headerlink" title="6.&emsp;项目源代码"></a><span style="color:black;text-shadow:5px 5px 5px #ccc ">6.&emsp;项目源代码</span></h2><p>百度网盘链接: 链接：<a href="https://pan.baidu.com/s/1FQU3OHlm9E7IU9_0DsJphQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1FQU3OHlm9E7IU9_0DsJphQ</a><br>提取码：qi9m </p>]]></content>
      
      
      <categories>
          
          <category> 三级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三级项目 </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的与数值相关的全局方法。</title>
      <link href="/2018/03/31/JavaScript%E4%B8%AD%E7%9A%84%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95/"/>
      <url>/2018/03/31/JavaScript%E4%B8%AD%E7%9A%84%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="皮卡丘洗脑"><a href="#皮卡丘洗脑" class="headerlink" title="皮卡丘洗脑"></a>皮卡丘洗脑</h2><a id="more"></a><p><img src="/images/emoji/滑稽.png">先来洗脑一下吧   </p><div><br>    <video src="/vedio/hc - 去吧皮卡丘,给我撸一发最带感的PikaPikaPi.mp4" controls="controls"><br>    </video><br></div><h2 id="全局方法概括"><a href="#全局方法概括" class="headerlink" title="全局方法概括"></a><span style="color:rgba(255,165,0,0.8);text-shadow:5px 5px 5px #ccc">全局方法概括</span></h2><p><span style="color:purple;text-shadow:5px 5px 5px #ccc ">1.&emsp;parseInt ( )</span></p><p><span style="color:orange;text-shadow:5px 5px 5px #ccc ">2.&emsp;parseFloat ( )</span></p><p><span style="color:green;text-shadow:5px 5px 5px #ccc ">3.&emsp;isNaN ( )</span></p><p><span style="color:red;text-shadow:5px 5px 5px #ccc ">4.&emsp;isFinate ( )</span></p><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a><span style="color:rgba(144,238,144,1);text-shadow:5px 5px 10px #ccc ">具体内容</span></h2><h2 id="1-emsp-parseInt"><a href="#1-emsp-parseInt" class="headerlink" title="1.&emsp;parseInt ( )"></a><span style="color:purple;text-shadow:5px 5px 5px #ccc ">1.&emsp;parseInt ( )</span></h2><p>（1）&ensp;基本用法<br>    </p><p>parseInt方法用于将字符串转为整数。</p><p></p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><hr><p>如果字符串头部有空格，空格会被自动去除。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'   81'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 81</span></code></pre><hr><p>如果parseInt的参数不是字符串，则会先转为字符串再转换。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">1.23</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token comment" spellcheck="true">// 等同于</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1.23'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1    </span></code></pre><p>（2）进制转换</p><p>parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制<br><br>数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1000</span>    <span class="token comment" spellcheck="true">// 等同于</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1000</span></code></pre><hr><p>下面是转换指定进制的数的例子。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 8</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 216</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 512</span>    上面代码中，二进制、六进制、八进制的<span class="token number">1000</span>，分别等于十进制的<span class="token number">8</span>、<span class="token number">216</span>和<span class="token number">512</span>。    这意味着，可以用parseInt方法进行进制的转换。</code></pre><hr><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 10</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 10</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">,</span> undefined<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 10</span></code></pre><hr><p>前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 43</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token comment" spellcheck="true">// 等同于</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 等同于</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'17'</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span>    <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'17'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></code></pre><pre><code>上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。</code></pre><p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p><h2 id="2-emsp-parseFloat"><a href="#2-emsp-parseFloat" class="headerlink" title="2.&emsp;parseFloat ( )"></a><span style="color:orange;text-shadow:5px 5px 5px #ccc ">2.&emsp;parseFloat ( )</span></h2><p>parseFloat方法用于将一个字符串转为浮点数。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'3.14'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3.14</span></code></pre><p>如果字符串符合科学计数法，则会进行相应的转换。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'314e-2'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3.14</span>    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'0.0314E+2'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3.14</span></code></pre><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'3.14more non-digit characters'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3.14</span>    parseFloat方法会自动过滤字符串前导的空格。    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'\t\v\r12.34\n '</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 12.34</span></code></pre><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span>    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'FF2'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span>    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span></code></pre><p>上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。</p><p>这些特点使得parseFloat的转换结果不同于Number函数。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// NaN</span>    <span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span>    <span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span>    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span>    <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span>    <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'123.45#'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 123.45</span>    <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'123.45#'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span></code></pre><h2 id="3-emsp-isNaN"><a href="#3-emsp-isNaN" class="headerlink" title="3.&emsp;isNaN ( )"></a><span style="color:green;text-shadow:5px 5px 5px #ccc ">3.&emsp;isNaN ( )</span></h2><p>isNaN方法可以用来判断一个值是否为NaN。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span></code></pre><p>但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串<br>的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，<br>isNaN为true的值，有可能不是NaN，而是一个字符串。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token comment" spellcheck="true">// 相当于</span>    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>出于同样的原因，对于对象和数组，isNaN也返回true。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token comment" spellcheck="true">// 等同于</span>    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'xzy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token comment" spellcheck="true">// 等同于</span>    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'xzy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>    <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'123'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span></code></pre><p>上面代码之所以返回false，原因是这些数组能被Number函数转成数值，请参见《数据类型转换》一章。</p><p>因此，使用isNaN之前，最好判断一下数据类型。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">function</span> <span class="token function">myIsNaN</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">function</span> <span class="token function">myIsNaN</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> value <span class="token operator">!==</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="4-emsp-isFinate"><a href="#4-emsp-isFinate" class="headerlink" title="4.&emsp;isFinate ( )"></a><span style="color:red;text-shadow:5px 5px 5px #ccc ">4.&emsp;isFinate ( )</span></h2><p>isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>    <span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>    <span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>    <span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>除了Infinity、-Infinity和NaN这三个值会返回false，isFinite对于其他的数值都会返回true。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js中的MD5加密</title>
      <link href="/2018/03/22/Node.js%E4%B8%AD%E7%9A%84MD5%E5%8A%A0%E5%AF%86/"/>
      <url>/2018/03/22/Node.js%E4%B8%AD%E7%9A%84MD5%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>先来一首陈势安的 《 天后 》来缓解一下疲惫的心情吧</p><div><br>    <video src="/music/天后-陈势安.mp3" controls="controls" style="background: url('/images/music/music1.jpg');background-size:100% 100%;"><br>    </video><br></div><h2 id="MD5简介"><a href="#MD5简介" class="headerlink" title="MD5简介"></a>MD5简介</h2><p><br>    <span style="font-size: 17px;color: purple">1.定义</span><br><br>        MD5即Message-Digest Algorithm 5（中文名为消息摘要算法第五版）为计算机安全领域广泛使用<br><br>        的一种散列函数，用以提供消息的完整性保护。<br></p><p><br>    <span style="font-size: 17px;color: #00e079">2.作用</span><br><br>    MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一<br><br>个任意长度的字节串变换成一定长的十六进制数字串）。除了MD5以外，其中比较有名的还有<br><br>    <span style="color: skyblue;">sha-1</span>、<span style="color: orange;">RIPEMD</span>以及<span style="color: green;">Haval</span>等。<br></p><p><br>    <span style="font-size: 17px;color: #a78e44">3.MD5算法特点</span><br><br>        MD5算法具有以下特点：<br><br>    (1) 压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br><br>    (2) 容易计算：从原数据计算出MD5值很容易。<br><br>    (3) 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br><br>    (4) 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困<br><br>&emsp;&nbsp;难的。<br></p><p><br></p><h2 id="Node-js使用MD5"><a href="#Node-js使用MD5" class="headerlink" title="Node.js使用MD5"></a>Node.js使用MD5</h2><pre class=" language-javascript"><code class="language-javascript">注<span class="token punctuation">:</span> MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：        <span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//引入crypto加密模块</span>        <span class="token keyword">const</span> hash <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span><span class="token string">'md5'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//规定使用哈希算法中的MD5算法</span>        <span class="token comment" spellcheck="true">// 可任意多次调用update(),效果相当于多个字符串相加</span>        hash<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">'123a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">'456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//最终加密的字符串为'123a456',hash.digest('hex')表示输出的格式为16进制</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 57d15a6ee827933b25dab42111b6803b</span>        <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法默认字符串编码为UTF<span class="token number">-8</span>，也可以传入Buffer。        注<span class="token punctuation">:</span>        如果要计算SHA1，只需要把<span class="token string">'md5'</span>改成<span class="token string">'sha1'</span>，就可以得到SHA1的结果        3be8b1b4c1b081f65522c4dd69b1d5c5713b038b。当然还可以使用更安全的sha256和sha512。</code></pre><p>同样,可以将MD5算法封装成一个函数 , 方便重复调用</p><pre class=" language-javascript"><code class="language-javascript">        <span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> md5 <span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span><span class="token string">'md5'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>目前单次的MD5加密并不安全,很容易被暴力破解,因此推荐多次加密和使用秘钥加密</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token number">1</span><span class="token punctuation">.</span>多次MD5加密        例如要加密 <span class="token string">'123'</span> 这个字符串           <span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> md5 <span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span><span class="token string">'md5'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        多次加密<span class="token punctuation">:</span>        <span class="token keyword">var</span> str<span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> pass<span class="token operator">=</span><span class="token function">md5</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> FinalPass<span class="token operator">=</span><span class="token function">md5</span><span class="token punctuation">(</span>pass<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>多次MD5加密不容易被破解,但是嵌套起来也比较麻烦, 因此我再介绍另外一种方法</code></pre><pre class=" language-javascript"><code class="language-javascript">    <span class="token number">2</span><span class="token punctuation">.</span>MD5结合秘钥加密        例如要加密 <span class="token string">'123'</span> 这个字符串           <span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> md5 <span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span><span class="token string">'md5'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        结合秘钥加密<span class="token punctuation">:</span>        <span class="token keyword">var</span> str<span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> md5_suffix<span class="token operator">=</span><span class="token string">'asd1wdad1d哈do捱三顶五#&amp;8qw'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//md5_suffix作为秘钥,越复杂越好</span>        <span class="token keyword">var</span> FinalPass<span class="token operator">=</span><span class="token function">md5</span><span class="token punctuation">(</span>str<span class="token operator">+</span>md5_suffix<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>结合秘钥使用MD5加密更难被破解,但是也有一定的缺陷,就是如果秘钥一旦丢失就无法进行验证</code></pre><h2 id="MD5加密语句的详细讲解"><a href="#MD5加密语句的详细讲解" class="headerlink" title="MD5加密语句的详细讲解"></a>MD5加密语句的详细讲解</h2><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">)</span>        创建并返回一个hash对象，它是一个指定算法的加密hash，用于生成hash摘要。        参数algorithm可选择系统上安装的OpenSSL版本所支持的算法。例如：<span class="token string">'sha1'</span><span class="token punctuation">,</span> <span class="token string">'md5'</span><span class="token punctuation">,</span> <span class="token string">'sha256'</span><span class="token punctuation">,</span>         <span class="token string">'sha512'</span>等。在近期发行的版本中，openssl list<span class="token operator">-</span>message<span class="token operator">-</span>digest<span class="token operator">-</span>algorithms会显示这些可用的摘要算法    <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> hash<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        更新hash的内容为指定的data。当使用流数据时可能会多次调用该方法。    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> hash<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">'binary'</span><span class="token punctuation">)</span>        计算所有传入数据的hash摘要。参数encoding（编码方式）可以为<span class="token string">'hex'</span><span class="token punctuation">,</span> <span class="token string">'binary'</span> 或者<span class="token string">'base64'</span>。    </code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/03/27/hello-world/"/>
      <url>/2017/03/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hhh </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js异步和网络Api发展史</title>
      <link href="/2017/03/27/js%E5%BC%82%E6%AD%A5%E5%92%8C%E7%BD%91%E7%BB%9Capi%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/2017/03/27/js%E5%BC%82%E6%AD%A5%E5%92%8C%E7%BD%91%E7%BB%9Capi%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从ajax到fetch，从回调到async，滑稽带你领略js异步和网络Api发展史。<br>仅仅是速览不会深入</p></blockquote><a id="more"></a><p>js是事件驱动的语言，单进程单线程。js主线程中有一个<code>Event Loop</code>（事件循环）。</p><h2 id="js运行顺序"><a href="#js运行顺序" class="headerlink" title="js运行顺序"></a>js运行顺序</h2><p>js先执行一遍所有js文件，然后进入<code>Event Loop</code>，等到有事件进入，就执行事件处理程序，执行完后再次回到<code>Event Loop</code>。</p><p>举个例子:</p><pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//死循环</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>如果你在浏览器中运行，页面会卡死（在一些浏览器中仍可以滚动），因为js不执行完，浏览器不会做任何响应。</p></blockquote><p>上面的代码永远不会输出hello，因为<code>setTimeout(...,0)</code>，虽然是延时0ms，但还是会在下一个事件循环中被调用。</p><p>而后面的<code>while</code>循环是死循环，js引擎永远执行不完，所以不会进入事件循环的，也就永远执行不到<code>timeout</code>里的代码</p><p>更详细的介绍可在<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮老师的博客</a>中看见。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>所以啥是异步呢？</p><p>我们先讲异步的反义词同步。</p><blockquote><p>同步就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p></blockquote><p>比如你发出一个网络请求请求一个数据，程序一直等待数据返回，不返回就不继续执行，这就是同步。</p><p>异步要智能得多。在网络请求没有返回之前程序还会继续执行。</p><p>延迟一秒在不同语言中同步、异步的不同写法:</p><p>JS 异步</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出 1 3 2</span></code></pre><p>Java 同步</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延迟1000ms</span>Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出 1 2 3</span></code></pre><p>显然<code>Java</code>的同步跟符合人类的思想，顺序执行非常简单。</p><p>但<code>JS</code>的优势也特别明显，在延迟时程序不会卡死，而是继续执行下去。</p><h2 id="回调（callback）"><a href="#回调（callback）" class="headerlink" title="回调（callback）"></a>回调（callback）</h2><p>回调是JS异步编程最常见的方式。</p><p><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="noopener">回调函数（callback）是什么？(逼乎)</a></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的<code>callback()</code>就作为回调函数，在1000ms后会被调用。</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>回到我们的主题，运用最广泛的网络api <code>ajax</code>就是以回调方式使用的。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> xmlhttp<span class="token punctuation">;</span>xmlhttp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义回调函数</span>xmlhttp<span class="token punctuation">.</span>onreadystatechange<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果请求完成 且 返回状态码为200</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>readyState<span class="token operator">==</span><span class="token number">4</span> <span class="token operator">&amp;&amp;</span> xmlhttp<span class="token punctuation">.</span>status<span class="token operator">==</span><span class="token number">200</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//输出内容</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"https://about.huaji8.top/links.json"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token comment" spellcheck="true">/*异步运行*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//发送</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>复制到浏览器<code>console</code>可以运行。</p></blockquote><blockquote><p><code>jquery</code>封装的ajax写法要比原版简单的多，对这是原版。</p></blockquote><blockquote><p>ajax也可以同步运行，只要将<code>XMLHttpRequest.open()</code>最后一个参数改成<code>false</code>，就是同步运行，执行<code>send()</code>后浏览器会卡住，直到请求返回。</p></blockquote><h2 id="Promise-（承诺）"><a href="#Promise-（承诺）" class="headerlink" title="Promise （承诺）"></a>Promise （承诺）</h2><p>Promise是一种更高级的回调接口。</p><blockquote><p>详细的介绍在这<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ECMAScript 6 入门</a>，<code>Promise</code>的好处千千万，建议大家全部使用<code>Promise</code>，<code>jquery</code>的所有异步api也全部支持<code>Promise</code></p></blockquote><blockquote><p>ES6 原生支持 Promise ， 在不支持的浏览器上可以使用垫片库 <a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="noopener">es6-promise</a></p></blockquote><p>下面是一个将<code>setTimeout()</code>改造成<code>Promise</code>的例子。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//返回一个Promise 就可以无限then()啦 还可以用catch()捕获异常</span><span class="token keyword">function</span> <span class="token function">setTimeoutP</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建Promise 如果成功就调用resolve，失败就调用reject</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">setTimeoutP</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回Promise 可以在then()中继续执行</span>    <span class="token keyword">return</span> <span class="token function">setTimeoutP</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回数据 可以在then()中获取</span>    <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//一秒后输出Hello</span></code></pre><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch 是新的网络api 基于 Promise 设计。在旧的浏览器上可以使用 <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="noopener">isomorphic-fetch</a>，这个api是 node 和 浏览器环境通用的，实现同构应用必备的库。</p><blockquote><p>注：同构(isomorphic/universal)就是使前后端运行同一套代码的意思，后端一般是指 NodeJS 环境。</p></blockquote><p>范例</p><pre class=" language-js"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"https://about.huaji8.top/links.json"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>尝试在浏览器<code>console</code>中运行</p></blockquote><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p><code>Generator 函数</code> 是 <code>ES6</code> 提供的语法，不过很快就被 <code>ES2017</code> 的 <code>async 函数</code> 代替，所以不多说了，感兴趣的可以看<a href="http://es6.ruanyifeng.com/?search=fetch&amp;x=0&amp;y=0#docs/generator" target="_blank" rel="noopener">ECMAScript 6 入门</a></p><blockquote><p>第一次看到 <code>Generator 函数</code> 是在 <code>unity</code> 中的协程，现在js也有这个语法了。</p></blockquote><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>重头来了，这是目前最屌的写法，真正用同步的写法写异步程序。</p><blockquote><p>async 实际是 <code>Generator 函数</code> 的语法糖， <code>Generator</code> 才是技术</p></blockquote><p>我们继续拿上面建的 <code>setTimeoutP()</code> 举例。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//返回一个Promise</span><span class="token keyword">function</span> <span class="token function">setTimeoutP</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建Promise 如果成功就调用resolve，失败就调用reject</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// await可以拿到Promise的返回值</span>    <span class="token keyword">let</span> O <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"https://about.huaji8.top/links.json"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">setTimeoutP</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>O<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一秒后输出 https://about.huaji8.top/links.json 内容</span><span class="token punctuation">}</span><span class="token function">asyncDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>尝试在浏览器<code>console</code>中运行</p></blockquote><h2 id="async-异常处理"><a href="#async-异常处理" class="headerlink" title="async 异常处理"></a>async 异常处理</h2><p><code>async</code> 可以以同步的方式编写异常处理。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> O <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"https://about.huaji8.top/links.json"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//输出异常</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">await</span> <span class="token function">setTimeoutP</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>O<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>是不是超级方便呢。</p><p>关于<code>async</code>的更多信息，可以查看<a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">ECMAScript 6 入门</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener">MDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> js </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
